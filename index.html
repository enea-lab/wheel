<!DOCTYPE html>
<html lang="it">

<head>
	<meta charset="UTF-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
	<title>TOGAF Wheel Complete</title>
	<style>
		body {
			margin: 0;
			overflow: hidden;
			/* Nasconde le barre di scorrimento */
			background: #f0f0f0;
			font-family: Arial, sans-serif;
			touch-action: none;
			/* Disabilita lo zoom/scroll tattile nativo per migliorare l'interazione */
		}

		canvas {
			display: block;
			background: #ffffff;
		}
	</style>
</head>

<body>

	<canvas id="wheelCanvas"></canvas>

	<script>
		const canvas = document.getElementById("wheelCanvas");
		const ctx = canvas.getContext("2d");

		// --- GESTIONE RESIZE ---
		function resizeCanvas() {
			canvas.width = window.innerWidth;
			canvas.height = window.innerHeight;
		}

		window.addEventListener('resize', () => {
			resizeCanvas();
			updateNodePositions();
			drawEverything();
		});
		resizeCanvas(); // Primo avvio

		// --- CONFIGURAZIONE GLOBALE ---
		let centerX = canvas.width / 2;
		let centerY = canvas.height / 2;
		const radius = 180; // Raggio logico della ruota
		const segmentAngle = (Math.PI * 2) / 8; // 45 gradi per settore

		// Angolo iniziale: -90° (-PI/2) per far partire "A" in alto a ore 12
		let angle = -Math.PI / 2;
		let isSpinning = false; // Flag per bloccare i click

		// --- CLASSE NODO ---
		class Node {
			constructor(label) {
				this.label = label;
				this.x = 0;
				this.y = 0;
				this.currentScale = 1; // Per l'effetto bump
			}

			draw() {
				ctx.save();
				// Spostiamo l'origine del disegno al centro di QUESTO nodo
				ctx.translate(this.x, this.y);
				// Applichiamo lo zoom locale (bump)
				ctx.scale(this.currentScale, this.currentScale);

				// Disegno cerchio (centrato su 0,0 locale)
				ctx.beginPath();
				ctx.fillStyle = "#f4d35e";
				ctx.strokeStyle = "#000";
				ctx.lineWidth = 2;
				ctx.arc(0, 0, 50, 0, Math.PI * 2);
				ctx.fill();
				ctx.stroke();

				// Testo
				ctx.fillStyle = "#000";
				ctx.font = "12px Arial"; // Font leggermente più piccolo per mobile
				ctx.textAlign = "center";
				ctx.textBaseline = "middle";

				const words = this.label.split("\n");
				words.forEach((w, i) => {
					ctx.fillText(w, 0, -20 + i * 14);
				});

				ctx.restore(); // Ripristina il contesto per il prossimo nodo
			}
		}

		// --- DEFINIZIONE NODI ---
		const orderedNodes = [
			new Node("A.\nArchitecture\nVision"),
			new Node("B.\nBusiness\nArchitecture"),
			new Node("C.\nInformation\nSystems\nArchitectures"),
			new Node("D.\nTechnology\nArchitecture"),
			new Node("E.\nOpportunities\nand\nSolutions"),
			new Node("F.\nMigration\nPlanning"),
			new Node("G.\nImplementation\nGovernance"),
			new Node("H.\nArchitecture\nChange\nManagement")
		];

		const baseAngles = orderedNodes.map((_, i) => i * segmentAngle);

		// --- CALCOLO POSIZIONI ---
		function updateNodePositions() {
			centerX = canvas.width / 2;
			centerY = canvas.height / 2;

			orderedNodes.forEach((node, i) => {
				const a = baseAngles[i] + angle;
				node.x = Math.cos(a) * radius;
				node.y = Math.sin(a) * radius;
			});
		}

		// --- DISEGNO GENERALE ---
		function drawEverything() {
			ctx.clearRect(0, 0, canvas.width, canvas.height);

			ctx.save(); // Salva stato iniziale (senza zoom globale)

			// 1. ZOOM RESPONSIVE
			const minDim = Math.min(canvas.width, canvas.height);
			const contentSize = 500; // Dimensione logica desiderata
			// Scala al 85% della dimensione minima dello schermo
			let scaleFactor = (minDim / contentSize) * 0.85;

			// Sposta al centro dello schermo e applica zoom
			ctx.translate(centerX, centerY);
			ctx.scale(scaleFactor, scaleFactor);

			// 2. LINEE ESTERNE (OTTAGONO)
			ctx.strokeStyle = "#000";
			ctx.lineWidth = 2;
			for (let i = 0; i < orderedNodes.length; i++) {
				const a = orderedNodes[i];
				const b = orderedNodes[(i + 1) % orderedNodes.length];
				ctx.beginPath();
				ctx.moveTo(a.x, a.y);
				ctx.lineTo(b.x, b.y);
				ctx.stroke();
			}

			// 3. RAGGI VERSO IL CENTRO
			orderedNodes.forEach(node => {
				ctx.beginPath();
				ctx.moveTo(0, 0); // 0,0 è il centro grazie al translate
				ctx.lineTo(node.x, node.y);
				ctx.stroke();
			});

			// 4. NODO "PRELIMINARY" (FISSO IN ALTO)
			// Posizionato a y = -350 (sopra la ruota)
			ctx.beginPath();
			ctx.moveTo(0, 0);
			ctx.lineTo(0, -350);
			ctx.stroke();

			ctx.beginPath();
			ctx.fillStyle = "#a3cef1";
			ctx.arc(0, -350, 70, 0, Math.PI * 2);
			ctx.fill();
			ctx.stroke();

			ctx.fillStyle = "#000";
			ctx.font = "16px Arial";
			ctx.textAlign = "center";
			ctx.textBaseline = "middle";
			ctx.fillText("Preliminary", 0, -350);

			// 5. MOZZO CENTRALE ("REQUIREMENTS")
			ctx.beginPath();
			ctx.fillStyle = "#a3cef1";
			ctx.arc(0, 0, 70, 0, Math.PI * 2);
			ctx.fill();
			ctx.stroke();

			ctx.fillStyle = "#000";
			ctx.font = "16px Arial";
			ctx.textAlign = "center";
			ctx.textBaseline = "middle";
			ctx.fillText("Requirements", 0, -10);
			ctx.fillText("Management", 0, 10);

			// 6. DISEGNO NODI RUOTANTI
			orderedNodes.forEach(n => n.draw());

			ctx.restore(); // Ripristina coordinate schermo intero
		}

		// --- ANIMAZIONE 2: EFFETTO BUMP (RIMBALZO) ---
		// Viene chiamata SOLO quando la rotazione è finita
		function triggerBumpEffect(targetNode, onComplete) {
			const bumpDuration = 600; // ms
			const bumpStart = performance.now();

			function animateBump(now) {
				const elapsed = now - bumpStart;
				let t = elapsed / bumpDuration;

				if (t >= 1) {
					targetNode.currentScale = 1; // Reset finale
					drawEverything();
					if (onComplete) onComplete(); // Sblocca il click
					return;
				}

				// Effetto onda sinusoidale: 1 -> 1.3 -> 1
				const scaleAmount = 0.3;
				targetNode.currentScale = 1 + Math.sin(t * Math.PI) * scaleAmount;

				drawEverything();
				requestAnimationFrame(animateBump);
			}
			requestAnimationFrame(animateBump);
		}

		// --- ANIMAZIONE 1: ROTAZIONE ---
		function spinWheel() {
			if (isSpinning) return; // Se sta già facendo qualcosa, ignora il click
			isSpinning = true;

			const start = angle;
			const fullSpins = 5; // Giri veloci
			const randomSegments = Math.floor(Math.random() * 8); // Spicchi extra casuali

			// Calcolo angolo finale (sempre additivo per senso orario)
			const rotationDelta = (fullSpins * Math.PI * 2) + (randomSegments * segmentAngle);
			const end = start + rotationDelta;

			const duration = 3000; // 3 secondi di rotazione
			const startTime = performance.now();

			function animate(now) {
				const elapsed = now - startTime;
				let t = elapsed / duration;

				// Fine della rotazione
				if (t >= 1) {
					t = 1;
					angle = end;
					updateNodePositions();

					// 1. Calcola chi è il "vincitore" (chi sta più in alto visivamente)
					// Nota: In canvas Y cresce verso il basso, quindi Y minore = più in alto
					let winnerNode = orderedNodes[0];
					orderedNodes.forEach(n => {
						if (n.y < winnerNode.y) winnerNode = n;
					});

					// 2. Avvia il Bump sul vincitore
					// Passiamo la callback per sbloccare isSpinning alla fine del bump
					triggerBumpEffect(winnerNode, () => {
						isSpinning = false;
					});

					return; // Stop questo loop
				}

				// Easing Cubic Out (veloce -> lento)
				const ease = 1 - Math.pow(1 - t, 3);
				angle = start + (end - start) * ease;

				updateNodePositions();
				drawEverything();
				requestAnimationFrame(animate);
			}

			requestAnimationFrame(animate);
		}

		// Event Listener
		canvas.addEventListener("click", spinWheel);

		// Avvio iniziale
		updateNodePositions();
		drawEverything();

	</script>
</body>

</html>